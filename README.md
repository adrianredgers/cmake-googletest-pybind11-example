Example (CLion) project to import a googletested C++ function into Python using pybind11 :-
-
- **Python**
- **Project targets**
- **Project files**
- **in-source** vs **out-of-source**:
- **CLion tips**
- **CMake**
- **pybind11**
- **Contact**


**Python**

What a palaver! The aim is that you should be able run a `cmake` script, then start up Python, import a module written
in C++ (and tested with googletest) that has a pybind11 interface, and run a function from that module:
```
$ ./compile.sh
$ ./build/myUnitTests
$ echo $?
0
$ python
Python 2.7.12 (default, Dec  4 2017, 14:50:18) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import myfactorial
>>> myfactorial.fact(5)
120.0
>>> myfactorial.hello("adrian")
Hello adrian
>>> ll=[-2, 4.5, 2]
>>> myfactorial.max(ll,3)
4.5
>>> quit()
``` 

**Project targets**
- The script `compile.sh` builds 3 targets: `FactorialLib`, `myfactorial` and `myUnitTests`
    - It creates them in the directory `build`
    - [If you run unit tests in CLion then CLion only builds `FactorialLib` and `myUnitTests` (see **Clion tips** below).]
- CMake target `FactorialLib` builds the shared library: `libFactorialLib.so` , which is used by the python module and the tests.
- CMake target `myfactorial` compiles `PyModule.cpp`, which includes `pybind11` source, and links with `FactorialLib` to build the Python module (shared library) `myfactorial.so`
    - A CMake custom-command then copies it to your Python distribution directory.
    - You should make sure your `$PYTHONPATH` and `$LD_LIBRARY_PATH` contain this distribution directory.
        - The script `compile.sh` shows how to do this idempotently.
- CMake target `myUnitTests` is an executable that runs the unit tests outside of CLion.
- Python looks for modules in `$PYTHONPATH`.
    - So we need to copy `myfactorial.so` to a directory and add that directory to `$PYTHONPATH`
- If the Python shared library module `myfactorial.so` needs another library then that needs to be in `$LD_LIBRARY_PATH`
    - So we need to copy `libMyFactorialLib.so` to a directory and add that directory to `$LD_LIBRARY_PATH`


**Project files**
- `CMakeLists.txt` - top-level CMake file that calls the other `main` and `test` CMake files.
- `compile.sh` 
    1) idempotently adds the user's home directory `~` to `$PYTHONPATH` and `$LD_LIBRARY_PATH`.
    2) creates the directory `build` to hold the artifacts.
    3) runs `cmake` and then `make`.
- `src\include`
    - `FactorialLib.h` - public interface include file. It's used by by the sources,
    and by any other C++, such as tests, that wants to use `libFactorialLib.so`.
- `src/main`
    - `CMakeLists.txt` - CMake for the main targets: `FactorialLib` and `myfactorial`.
    - `Factorial.cpp Factorial_p.h` - private C++ source of our function (that we want to import into Python).
    - `PyModule.cpp` - pybind11 interface of our function in the Python module `myfactorial.so`.
    - `lib/pybind11` - pybind11 C++ source code.
        - Not a library - it's `#include`-d in `PyModule.cpp`.
        - Cloned from: `git@github.com:pybind/pybind11.git`.
        - Delete its .git file, and then rename it if necessary so your git picks it up.
- `src/test`
    - `CMakeLists.txt` - CMake for test target: `myUnitTests`.
        - **NOTE** compile.sh runs tests labelled `<xxx>UnitTests` in the CMake file.
    - `FactorialTest.cpp` - googletests of the `FactorialLib` library.
    - `lib/googletest` - googletest C++ source code.
        - It is a library that is linked to the tests.
        - Cloned from: `git@github.com:google/googletest.git`.
        - Delete its .git file, and then rename it if necessary so your git picks it up.
- `build` - temporary directory containing targets and artifacts.
    - Auto-generated, not under source code control
    - Regenerated by running `compile.sh`.
- `cmake-build-debug` - another temporary directory, created by CLion.
    - Annoyingly generated by CLion until you set out-of-source dir to `build` (see **CLion tips** below).


**in-source** vs **out-of-source** builds
- An **in-source** build creates build artifacts next to files in the source tree.
    - You can do this by running `cmake` (and `make`) in the project directory.
        - **DON'T DO THIS** it will create build arifacts throughout your source tree - hard to get rid of them.
- An **out-of-source** build creates build artifacts in a directory (structure) that you choose.
    - Easy to remove and re-generate all build artifacts: just delete the out-of-source build dir and re-make.
    - The script `compile.sh` does this by creating a directory, `build`, `cd`-ing to it and running `cmake` and `make` from there.
- By default CLion builds out-of-source in the directory `cmake-build-debug`, but you can change this (see **CLion Tips** below).


**CLion tips:**
- [GOTCHA Can't edit any files? CLion uses VIM by default. Get rid of VIM by removing the VIM plugin.]
- Clone this template project from GitHub, then clone it locally:
    - `git clone git@github.com:adrianredgers/cmake-googletest-pybind11-example.git` 
    - `git clone cmake-googletest-pybind11-example <your-new-directory>`.
- Navigate to the new project and open it in CLion:
    - `Import Project...`, or `Import Project from Sources`.
    - In response to the dialogue box, select `Import Project`. Do **not** select `Overwrite CMakeLists.txt`.
- Note: `Ctrl-Shift-T` does not work for switching to tests, but `Ctrl-Shift-F10` still runs tests.
- Optional, but probably worthwhile, is marking `src` as a source directory:
    - Right-click on project window.
    - Select `Mark directory as > Project Sources and Headers`.
- Optional convenience step: set out-of-source build directory in CLion:
    - In `File menu > Settings > Build, Generation, Deployment > CMake`  set the `Generation path:` to `build`.
    - Optional because it means CLion puts all build artifacts in the directory `build`, instead of some of them in `cmake-build-debug`.
- You can always delete `build` and `cmake-build-debug` and regenerate them with a rebuild.
- CLion CMake is lazy - it only builds what it uses.
    - So it builds the `FactorialLib` and `myUnitTests` needed to run tests in CLion.
    - But it does not build the Python module target `myfactorial`
    - Hence the need for `compile.sh`


**CMake tips:**
- This project sets the location of each created target individually with `set_target_properties`.
    - Alternatively, they could be set globally by setting `CMAKE_*_OUTPUT_DIRECTORY*`.
- Ob. Hack: `pybind11_add_module` has a _feature_ that causes it to look for Python 3.5.
    - So we need to set `PYBIND11_PYTHON_VERSION` before you add the pybind11 sub-directory.
    - Some details of this in `https://github.com/pybind/pybind11/issues/587`.
- Note the use of keywords like `SHARED` and `PRIVATE`.


**pybind11**
- Docco: https://zenodo.org/record/239703/files/pybind11%20basics.pdf


**Contact me**
- This is my first attempt at a lot of things - CMake, CLion, googletest, python, pybind11, C++, GitHub, README ml.
- I would be grateful for any (non-painful) suggestions:-
    - aredgers@yahoo.com
        

